#include<bits/stdc++.h>
using namespace std;
/*这题目真有意思
  非常的有意思(还对脑子有好处)
  我试了大概一个小时*/

string a,b,c;//输入的三个字符串
char d[30];//存储每个字母对应密文的字符串
int l;//临时变量，字符串长度
bool flag[30]={false};//干嘛用的就不解释了
/*
  这个flag[] 让我卡了将近20分钟
  很重要 不然可能会出现
  		NM
  		NN
  	这种情况，不用flag[]直接原地WA
*/

int main(){//主函数
	memset(d,0,sizeof(d));
	//把将要用于存储密文的数组初值设置为0，便于后面的判断
	cin>>a>>b>>c;//读入三行字符串
	l=a.size();
	/*(l第一次散发光辉) l设置为原始文字字符串的长度
	  由于题目中已经说明两个存储密文的字符串长度相同
	  所以无需考虑长度不相同的情况
	*/
	for(int i=0;i<26;i++){
	//26个字母，循环26次用来存储每个字母对应密文
				/*判断：密文是否出现重复(原理很简单 实操需要充分理解题目)
		题目说存在两种Failed的情况：
		1. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现
		2. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反编码规则）
		
		对于第一种情况, 代码在60-63行
			如果最后flag数组中还有哪个/些字母的位置没有改为true(即没被标记
			过), 就说明这个/些字母是缺失的, 则直接Failed

		对于第二种情况, 代码就是下面if语句中的内容
			自相矛盾是分两种情况的, 即
				1. 同一个字母多个密文，
					需要判断密文对应字母的地方是否有其他密文
					如果有, 输出Failed
				2. 同一个密文多个字母
					flag数组的重要性就体现在这里!
					如果此时循环到的密文(b[i])在flag数组中被标记过，
					就说明这个密文已经对应了其他字母，此时直接Failed
		*/
		if(d[a[i]-65]==b[i]||flag[b[i]-65]){
		// 同一个字母多个密文	   同一个密文多个字母
			cout<<"Failed";return 0;
		}
		else{
			d[a[i]-65]=b[i];//密文对应工作
			flag[b[i]-65]=true;//改flag!!!
		}
	}
	for(int i=0;i<26;i++){//上面
		if(!flag[i]){
			cout<<"Failed";return 0;
		}
	}
	l=c.size();//(l第二次散发光辉) l设置为需要解密的数组的长度
	for(int i=0;i<l;i++) printf("%c",d[c[i]-65]);
	//按照密文对照数组输出解密后的文字
	return 0;//结束程序
}
//当时真的被这道题搞疯了
//一个程序70行代码，注释就占了一大半[doge]