## 测试
### 第二题
<https://www.luogu.com.cn/problem/P3871>

如果使用sort，时间复杂度过于复杂，会超时
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110005];
int cnt=0;
void mid(){
	sort(a,a+cnt);
	if(cnt%2==0) cout<<a[cnt/2-1]<<endl;
	else cout<<a[cnt/2]<<endl;
}
int main(){
	int n,b;
	cin>>n;
	cnt=n;
	for(int i=0;i<n;i++) cin>>a[i];
	string s;
	cin>>n;
	while(n--){
		cin>>s;
		if(s=="add"){
			cin>>b;
			a[cnt++]=b;
			getline(cin,s);
		}else if(s=="mid") mid();
	}
    return 0;
}

```
能拿30分

因为原先的数组已经有序，如果新加一个数据能继续排序，则可以使用set或优先队列

#### 维护第k大数
给定一个初始序列，之后每一次新加一个数，每加进一个数，都输出当前序列的第k大数

优先队列示例
```cpp
//基本操作
#include <bits/stdc++.h>
using namespace std;

int main(){
	priority_queue<int> pq;
	pq.push(3);
	pq.push(6);
	pq.push(4);//时间复杂度: o(n)
	pq.push(2);
	cout<<pq.top()<<endl;//时间复杂度: o(1)
	pq.pop();
	cout<<pq.top()<<endl;
    return 0;
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	priority_queue<int,vector<int>,less<int> > pq;//大在前
	priority_queue<int,vector<int>,greater<int> > pq1;//大在前
	for(int i=0;i<5;i++){
		int t;
		cin>>t;
		pq.push(t);
		pq1.push(t);
	}
	while(!pq.empty()){
		cout<<pq.top()<<" ";
		pq.pop();
	}
	cout<<endl;
	while(!pq1.empty()){
		cout<<pq1.top()<<" ";
		pq1.pop();
	}
    return 0;
}

```
input
```
7 2 1 8 3
```
output
```
8 7 3 2 1
1 2 3 7 8
```

如果每一次都重新排序，复杂度太高了，如果我们关注前k大的数，复杂度就会降低

#### 本题做法：建两个堆，一个大根堆，一个小根堆，把第一个数当作中位数

```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> > p;//小根堆
priority_queue<int,vector<int>,less<int> > q;//大根堆
int mid;

int main(){
	int n;
	cin>>n;
	cin>>mid;//第一个数当作中位数
	for(int i=1;i<n;i++){
		int t;
		cin>>t;
		if(t>mid) p.push(t);
		else q.push(t);
        if(p.size()>q.size()+1){
            q.push(mid);
            mid=p.top();
            p.pop();
        } else if(q.size()>p.size()){
            p.push(mid);
            mid=q.top();
            q.pop();
        }
	}
	cin>>n;
	string s;
	while(n--){
		cin>>s;
		if(s=="add"){
			int t;
			cin>>t;
			if(t>mid) p.push(t);
            else q.push(t);
            if(p.size()>q.size()+1){
                q.push(mid);
                mid=p.top();
                p.pop();
            } else if(q.size()>p.size()){
                p.push(mid);
                mid=q.top();
                q.pop();
            }
		}else if(s=="mid") cout<<mid<<endl;
		else cout<<s<<endl;
	}
    return 0;
}
```

### 第四题
如果按照以下写法，则无法运行
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[50005],b[50005],c[2500000005];
bool cmp(long long a,long long b){
	return a<b;
}
int main(){
    int n,cnt=0;
	cin>>n;
	for(int i=0;i<n;i++) scanf("%lld",&a[i]);
	for(int i=0;i<n;i++) scanf("%lld",&b[i]);
	sort(a,a+n,cmp);
	sort(b,b+n,cmp);
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			c[cnt++]=a[i]+b[j];
		}
	}
	sort(c,c+cnt,cmp);
	for(int i=0;i<n;i++) printf("%lld ",c[i]);
    return 0;
}
```
当然，这种思路在数据小的时候完全可行

当面对较大数据时，可以使用优先队列进行解答

#### 拓展：结构体重载

如果结构体直接比较大小，会报错
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}a,b;
int main(){
	if(a>b){
		cout<<"Y";
	}else cout<<"N";
    return 0;
}
```
进行重载后
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y;    //第一个数据
	bool operator<(const node &rhs)const{//rhs: 第二个数据
		if(x!=rhs.x){//通常，第一个数写在左边，第二个数写在右边
			return x<rhs.x;
		}else{
			return y<rhs.y;
		}
	}
}a,b;
int main(){
	if(a<b){
		cout<<"Y";
	}else cout<<"N";
    return 0;
}
```
output
```
Y
```
#### 所以这题如果重载运算符，要这么写
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int sum;
	int ai,bi;
	bool operator<(const node &rhs)const{
		return sum>rhs.sum;
	}
};
int a[50005],b[50005];
priority_queue<node,vector<node>,less<node> > pq;
int main(){
	// freopen("nsum.in","r",stdin);
	// freopen("nsum.out","w",stdout);
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i];
	for(int i=0;i<n;i++) cin>>b[i];
	sort(a,a+n);
	sort(b,b+n);
	for(int i=0;i<n;i++){
		pq.push({a[i]+b[0],i,0});
	}//优先队列初始化
	for(int i=0;i<n;i++){
		cout<<pq.top().sum<<" ";
		node t=pq.top();//把top存起来
		pq.push({a[t.ai]+b[t.bi+1],t.ai,t.bi+1});
		pq.pop();
	}
    return 0;
}
```
