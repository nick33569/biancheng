##### 听说云笔记更很有实力，但是它不支持数学公式，所以还是博客有实力
#### 目前有1-5题 预计用3天写到15题 ~~程序题全靠蒙~~
## csp-s 2022第一轮
#### 题目来源：<https://ti.luogu.com.cn/problemset/1040>

---
#### 1. 在 Linux 系统终端中，用于切换工作目录的命令为（ ）。
#### A. ls B. cd C. cp D. all
以下是Linux常用对于文件操作的常见命令
> ![image](https://www.itbunan.xyz/usr/uploads/2022/03/342592171.png)
> 
> 来源：<https://www.itbunan.xyz/liu/7.html>

通过审题和上面的图片，可知Linux系统中切换工作目录的命令为cd，所以选择B

---
#### 2. 你同时用 time 命令和秒表为某个程序在单核 CPU 的运行计时。假如 time 命令的输出如下：
```
real   0m30.721s 
user   0m24.579s 
sys    0m6.123s
```
#### 以下最接近秒表计时的时长为（ ）。
#### A. 30s B. 24s C. 18s D. 6s
> `time`是一个Unix操作系统上的命令。它可以用于确定执行特定命令持续的时间。
> 
> 来源：<https://zh.wikipedia.org/wiki/Time_(Unix)>

在time命令的输出中，"real"为实际时间，"user"为用户cpu时间，"sys"为系统时间
根据上述内容，接近秒表计时的量应当为`real   0m30.721s `，对应题目中A选项：30s

---
#### 3. 若元素 a、b、c、d、e、f 依次进栈，允许进栈、退栈操作交替进行，但不允许连续三次退栈操作，则不可能得到的出栈序列是（ ）。

#### A. dcebfa B. cbdaef C. bcaefd D. afedcb
实现过程：
A. dcebfa
```cpp
#include<bits/stdc++.h>
using namespace std;
stack<char> stk;
#define pop stk.pop();
#define pa stk.push('a');
#define pb stk.push('b');
#define pc stk.push('c');
#define pd stk.push('d');
#define pe stk.push('e');
#define pf stk.push('f');//为了让代码变得方便看(更加抽象)
//main函数中为入、退栈过程
int main(){//main函数中所有注释后跟的字母均为当前栈中元素
    pa//a
    pb//a,b
    pc//a,b,c
    pd//a,b,c,d
    pop//a,b,c   pop:1
    pop//a,b     pop:2
    pe//a,b,e
    pop//a,b     pop:1
    pop//a       pop:2
    pf//a,f
    pop//a       pop:1
    pop//empty   pop:2
    return 0;//经过验证，代码可以运行，无需担心语法问题
}
```
可以发现在这个过程中所有退栈次数均未超过3次，则成立

B. cbdaef
```cpp
int main(){//由于前面部分相同，则只展示main函数
    pa//a
    pb//a,b
    pc//a,b,c
    pop//a,b    pop:1
    pop//a      pop:2
    pd//a,d
    pop//a      pop:1
    pop//empty  pop:2
    pe//e
    pop//empty  pop:1
    pf//f
    pop//empty  pop:1
    return 0;
}
```
可以发现在这个过程中所有退栈次数均未超过3次，则成立

C. bcaefd
```cpp
int main(){
    pa//a
    pb//a,b
    pop//a      pop:1
    pc//a,c
    pop//a      pop:1
    pop//empty  pop:2
    pd//d
    pe//d,e
    pop//d      pop:1
    pf//d,f
    pop//d      pop:1
    pop//empty  pop:2
    return 0;
}
```
可以发现在这个过程中所有退栈次数均未超过3次，则成立

D. afedcb
```cpp
int main(){
    pa//a
    pop//empty   pop:1
    pb//b
    pc//b,c
    pd//b,c,d
    pe//b,c,d,e
    pf//b,c,d,e,f
    pop//b,c,d,e pop:1
    pop//b,c,d   pop:2
    pop//b,c     pop:3
    pop//b       pop:4
    pop//empty   pop:5
    return 0;
}
```
由于在此过程中，退栈次数已经超过了3，则不成立

所以选择D

---
#### 4. 考虑对 n 个数进行排序，以下最坏时间复杂度低于 $O(n^2)$ 的排序方法是（ ）。
#### A. 插入排序 B. 冒泡排序 C. 归并排序 D. 快速排序
 
> #### 时间复杂度
> 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。
> 
> 当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。
> 
> 时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。
> 
> 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。
> 
> #### 大O记法
> 我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。
> 
> 此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。
> 
> “大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。
> 
> 这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。
> 
> #### 最坏时间和平均时间
> 最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。
> 
> 在最坏情况下的时间复杂度为T(n)=0(n)，它表示对于任何输入实例,该算法的运行时间不可能大于0(n)。 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。
>
> #### 求解算法的时间复杂度的具体步骤是：
> 
> 1. 找出算法中的基本语句；
> 
>     算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。
> 
> 2. 计算基本语句的执行次数的数量级；
> 
>     只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。
> 
> 3. 用大Ο记号表示算法的时间性能。
> 
>     将基本语句执行次数的数量级放入大Ο记号中。
> 
>来源：https://blog.csdn.net/stary_yan/article/details/51383480

各种排序算法的时间复杂度、空间复杂度和稳定性如下
>![](https://cdn.luogu.com.cn/upload/image_hosting/7uiqtawv.png)
>
> 来源：自己照着网上的做的

通过上面的文字和表格可知，在选项中的四个排序算法中，最坏时间，时间复杂度低于 $O(n^2)$ 的排序方法是 C. 并归排序

---
#### 5. 假设在基数排序过程中，受宇宙射线的影响，某项数据异变为一个完全不同的值。请问排序算法结束后，可能出现的最坏情况是（ ）。
#### A. 移除受影响的数据后，最终序列是有序序列
#### B. 移除受影响的数据后，最终序列是前后两个有序的子序列
#### C. 移除受影响的数据后，最终序列是一个有序的子序列和一个基本无序的子序列
#### D. 移除受影响的数据后，最终序列基本无序
~~说是这么说，但我根本不知道基数排序是个啥~~
>你说得对，但是基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
>
>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
>
> 来源：<https://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F>

所以我个人认为，在移除掉受影响的数据以后，原排序不受影响，最终序列仍然是一个有序序列，选择A
