其实并没有做完 但是因为~~要睡觉了~~没时间了 所以就不做了
#### 题目来源：https://ti.luogu.com.cn/problemset/1036
## 第 1 题
### 以下不属于面向对象程序设计语言的是（ ）。

 A. C++
 B. Python
 C. Java
 D. C
 
#### 面向过程（Procedure Oriented 简称PO ：如C语言）：

是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。

#### 面向对象（Object Oriented简称OO ：如C++，JAVA，Python等语言）：

是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。

例如，去餐馆吃饭，我们并不知道饭菜是怎么做出来的，只需要告诉服务员我们点的菜即可，此过程中不注重过程，即为面向对象；在家自己做饭时，则需要

则在此题中，选项A、B、C均属于面向对象的编程语言，而选项D位面向过程的编程语言

#### 则此题答案：D


------------

## 第5题
### 对于入栈顺序为 a,b,c,d,e 的序列，下列（ ）不是合法的出栈序列。

A. a,b,c,d,e

顺序：按照a,b,c,d,e的顺序依次先入后出

B. e,d,c,b,a

顺序：先全部入栈，再全部出栈

C. b,a,c,d,e

顺序：a、b入栈，再全部出栈，进栈三次后全部出

D. c,d,a,e,b

错的

#### 答案是D


------------
## 第6题
### 对于有 n 个顶点、m 条边的无向连通图 (m>n)，需要删掉（ ）条边才能使其成为一棵树。

 A. n−1
 B. m−n
 C. m−n−1
 D. m−n+1

#### 答案是D


------------
## 第11题
### 在数据压缩编码中的哈夫曼编码方法，在本质上是一种（ ）的策略。

 A. 枚举
 B. 贪心
 C. 递归
 D. 动态规划
 
####  枚举：
通俗来说，枚举就是对一个对象的所有可能取到的值的集合。例如“星期”这个词就是一个枚举，星期一、星期二、 星期三、星期四、星期五、星期六、星期日就是这个枚举里面的成员。
#### 贪心：
贪心是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。
#### 递归：
递归
在数学与电脑科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。

例如，从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”
#### 动态规划：
动态规划（简称DP）是一种在数学、管理科学、电脑科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

## 第13题
### 考虑如下递归算法
```
solve(n)  
     if n<=1 return 1  
      else if n>=5 return n*solve(n-2)  
      else return n*solve(n-1)  
```
则调用`solve(7)`得到的返回结果是（  ）(选项不写了)
```cpp
#include<bits/stdc++.h>
using namespace std;
int solve(int n){
    if(n<1) return 1;
    else if(n>=5) return n*solve(n-2);
    else return n*solve(n-1);
}
int main(){
    cout<<solve(7);
    return 0;
}

/*过程：
记s(x)=solve(x)
s(7)
7*s(7-2)
7*5*s(5-2)
7*5*3*s(3-1)
7*5*3*2*s(2-1)
7*5*3*2*1
*/
```
